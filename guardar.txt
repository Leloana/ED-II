        Node* atual = Tree->root;//"atual" é o ponteiro que percorrerá a arvore
    printf("    %d", atual->chave);
    printf("\nDeleting...\n");
    while (atual->chave != value || atual != NULL) {//Se atual == NULL significa que chegou ao fim da arvore
        if(value == atual->chave)break;
        else if (value < atual->chave)atual = atual->esq;
        else if(value > atual->chave)atual = atual->dir;

    }
    if(!atual)printf("\nValor nao encontrado!!\n");//Caso atual seja == NULL o valor nao existe na arvore
    else{//Caso haja o valor que quer ser deletado
        if(atual->color == 1){//Caso o no seja vermelho
        //=============== CASO 1 =======================
            if((atual->dir == NULL) && (atual->esq == NULL)){
                printf("\nDelet Red 1\n");
                if(atual->pai->esq == atual)atual->pai->esq = NULL;
                else atual->pai->dir = NULL;

                free(atual);//Caso seja uma folha 
            }
            else if((atual->dir != NULL) && (atual->esq != NULL)){//Caso Tenha algum filho
                printf("\nDelet Red 2\n");
                Node *aux;//Node apagado recebera o maior a direita
                aux = atual->dir;

                while(aux->esq != NULL)aux = aux->esq;//devo procurar o menor node da direita
                printf("%d", aux->chave);
                atual->chave = aux->chave;//valor a ser deletado recebe menor valor a sua direita
                aux->chave = value;//aux recebe o valor a ser deletado
                printf("  %d\n\n", aux->chave);


                Root auxTree;
                auxTree.root = atual->dir;

                deleteNode(&auxTree,value);
            }
        }
        else{//Caso o no seja preto
            if((atual->dir == NULL) && (atual->esq == NULL)){//Caso seja uma folha preta
                 printf("\nDelet black 1\n");
                if(atual->pai->esq == atual)atual->pai->esq = NULL;
                else atual->pai->dir = NULL;

                deleteFixup(Tree, atual, atual->pai);
                free(atual);//Caso seja uma folha 
            }
            else{
                if((atual->dir != NULL) || (atual->esq != NULL)){//se tiver algum galho
                    Node* aux;
                    if(atual->dir) aux = atual->dir;//aux recebe o no que existir
                    else aux = atual->esq;
                    if(aux->color == 1){//caso seja vermelho
                    //=============== CASO 2 =======================
                    printf("\nBlack 2\n");

                        while(aux->esq != NULL)aux = aux->esq;//devo procurar o menor node da parte direita
                        atual->chave = aux->chave;//valor a ser deletado recebe menor valor a sua direita
                        aux->chave = value;//aux recebe o valor a ser deletado
                        
                        // DoubleBlack = aux;
                        printf("\n\n%d\n\n", atual->chave);
                        Root auxTree;
                        if(atual->dir) auxTree.root = atual->dir;//aux recebe o no que existir
                        else auxTree.root = atual->esq;

                        deleteNode(&auxTree,value);
                    }
                    else{//caso seja preto 

                    }
                }
            }
        }
    }








    Node* atual = Tree->root;//"atual" é o ponteiro que percorrerá a arvore
    printf("    %d", atual->chave);
    printf("\nDeleting...\n");
    while (atual->chave != value || atual != NULL) {//Se atual == NULL significa que chegou ao fim da arvore
        if(value == atual->chave)break;
        else if (value < atual->chave)atual = atual->esq;
        else if(value > atual->chave)atual = atual->dir;

    }
    if(!atual){
        printf("\nValor nao encontrado!!\n");//Caso atual seja == NULL o valor nao existe na arvore
        return;
    }
    if(atual->color == 0){//se o no for preto
        if(atual->dir && atual->esq){//caso tenha os dois filhos
            int originalColor = 0;
            Node *aux;//Node apagado recebera o menor a direita
            aux = atual->dir;

            while(aux->esq != NULL)aux = aux->esq;//devo procurar o menor node da direita
            transplant(Tree,aux, aux->dir);
            aux->dir = atual->dir;
            atual->dir->pai = aux;

            transplant(Tree,atual, aux);
            // DeleteFix(aux->dir->esq);
        }
        else if(atual->dir || atual->esq){//caso tenha um dos nos apenas
            Node* aux;
            if(atual->dir){//separei mas acho q sao iguais
                int originalColor = 0;
                aux = atual->dir ;

                transplant(Tree,atual, aux);
                // DeleteFix(aux);//seta aux para preto
            }
            else{
                 aux = atual->esq;
            }
        }

    }